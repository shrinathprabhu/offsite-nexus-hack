{"version":3,"file":"vendors-node_modules_viem__esm_index_js.js","mappings":";;;;;;;;;;;;;;;;;AAAoE;AACG;AACnB;AACyB;AAC7E;AACA,6CAA6C;AAC7C;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA,kCAAkC,eAAe,eAAe,gBAAgB;AAChF;AACA,mBAAmB,cAAc;AACjC;AACA;AACO;AACP;AACA;AACA,uBAAuB,oEAAkB;AACzC,qBAAqB;AACrB,SAAS;AACT;AACA,wBAAwB,iEAAY;AACpC;AACA,wBAAwB,YAAY;AACpC;AACA,gBAAgB,yEAAiB;AACjC;AACA,2BAA2B,oEAAkB,cAAc,SAAS,0EAAW;AAC/E;AACA;AACA;AACA;AACA,kBAAkB,6EAAwB,GAAG,OAAO;AACpD;AACA;AACA,6C;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,yCAAyC,MAAM;AACtD;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,2C;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA,mBAAmB,YAAY;AAC/B,KAAK;AACL;AACA,qC;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,YAAY;AAC/B,KAAK;AACL;AACA,uC;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA,4C;;;;;;;;;;;;;;;ACzB8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP,YAAY,kBAAkB;AAC9B;AACA,KAAK;AACL;AACA,iBAAiB,uEAAW;AAC5B,gBAAgB,uEAAW;AAC3B;AACA;AACA,2C;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,4CAA4C,SAAS;AAC5D;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,8C;;;;;;;;;;;;;;;AC5B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,sCAAsC,SAAS;AACtD;AACA;AACA,iBAAiB,qEAAW;AAC5B,KAAK;AACL;AACA,wC;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA,yC;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,6BAA6B,gBAAgB;AAC7C;AACO,mCAAmC,OAAO;AACjD;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,qC;;;;;;;;;;;;;;;AC1B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wBAAwB,WAAW;AACnC;AACO,8BAA8B,kBAAkB;AACvD;AACA;AACA;AACA,uBAAuB,QAAQ,qEAAW,UAAU;AACpD,SAAS;AACT;AACA;AACA,uBAAuB,YAAY;AACnC,qBAAqB,qEAAW,UAAU,qEAAW;AACrD,SAAS;AACT;AACA,gC;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA,mBAAmB,YAAY;AAC/B,KAAK;AACL;AACA,wD;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,yBAAyB,qBAAqB;AAC9C;AACO,+BAA+B,0BAA0B,IAAI;AACpE;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,WAAW,gDAAgD;AAC9E,KAAK;AACL;AACA,iC;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0BAA0B,WAAW;AACrC;AACO,gCAAgC,IAAI;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA,kC;;;;;;;;;;;;;;;;AC1B4D;AAC6B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mCAAmC;AACnC;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACO;AACP,YAAY,uGAAuG;AACnH;AACA,kCAAkC,6FAAwB;AAC1D;AACA;AACA,WAAW,qEAAO,SAAS,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mD;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uC;;;;;;;;;;;;;;;AChC4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,qCAAqC;AACjD,YAAY,UAAU;AACtB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACO,oCAAoC,gBAAgB;AAC3D;AACA;AACA;AACA,8BAA8B,qEAAW;AACzC,SAAS;AACT;AACA;AACA,uBAAuB,YAAY;AACnC,8BAA8B,qEAAW;AACzC,SAAS;AACT;AACA,sC;;;;;;;;;;;;;;;ACpC4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oCAAoC,oBAAoB;AACxD;AACO,0CAA0C,UAAU;AAC3D;AACA;AACA,iBAAiB,qEAAW;AAC5B,KAAK;AACL;AACA,4C;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,6CAA6C,aAAa;AAC1D;AACO,mDAAmD,UAAU;AACpE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,qD;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACO,iCAAiC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,YAAY;AACnC;AACA,SAAS;AACT;AACA,mC;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,qCAAqC,SAAS;AACrD;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,uC;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,qCAAqC,aAAa;AAClD;AACO,2CAA2C,UAAU;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,6C;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,6C;;;;;;;;;;;;;;;ACzB4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,oCAAoC;AAChD,YAAY,UAAU;AACtB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,wCAAwC,UAAU;AACzD;AACA,mBAAmB,YAAY;AAC/B,iBAAiB,qEAAW;AAC5B,KAAK;AACL;AACA,0C;;;;;;;;;;;;;;;AC/B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,oCAAoC;AAChD,YAAY,UAAU;AACtB,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,mDAAmD,eAAe;AACzE;AACA,mBAAmB,YAAY;AAC/B,iBAAiB,qEAAW;AAC5B,KAAK;AACL;AACA,qD;;;;;;;;;;;;;;;AC7B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,yCAAyC,wBAAwB;AACjE;AACO,+CAA+C,WAAW;AACjE;AACA;AACA,iBAAiB,qEAAW;AAC5B,KAAK;AACL;AACA,iD;;;;;;;;;;;;;;;AC3B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACO,kCAAkC,gBAAgB;AACzD;AACA,mBAAmB,YAAY;AAC/B,0BAA0B,qEAAW;AACrC,KAAK;AACL;AACA,oC;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,qC;;;;;;;;;;;;;;;AC1B4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACO,sCAAsC,uBAAuB;AACpE;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA,wCAAwC,qEAAW;AACnD;AACA;AACA,KAAK;AACL;AACA,wC;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA,oC;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,UAAU;AACtB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACO,kDAAkD,SAAS;AAClE;AACA,mBAAmB,YAAY;AAC/B;AACA,KAAK;AACL;AACA,oD;;;;;;;;;;;;;;;;AC5BkD;AACC;AAC5C;AACP,YAAY,2CAA2C;AACvD,mBAAmB,8DAAY;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,gEAAW,GAAG,MAAM;AAC/B,KAAK;AACL;AACA,4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfyE;AACZ;AACI;AACU;AACF;AACM;AACZ;AACE;AACR;AACX;AACgD;AAC9C;AACE;AACmC;AACzB;AACD;AACY;AACkB;AACrC;AACS;AACY;AACD;AACL;AACsB;AACR;AAC1B;AACC;AACO;AACT;AACiC;AACpF,uBAAuB,OAAO;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA,uCAAuC,iFAAe;AACtD,6BAA6B,qEAAS;AACtC,+BAA+B,yEAAW;AAC1C,oCAAoC,mFAAgB;AACpD,mCAAmC,iFAAe;AAClD,0CAA0C,uFAAkB;AAC5D,oCAAoC,2EAAY;AAChD,iCAAiC,6EAAa;AAC9C,iCAAiC,qEAAS;AAC1C,4BAA4B,2DAAI;AAChC,gDAAgD,4GAA4B;AAC5E,6BAA6B,8DAAK;AAClC,8BAA8B,gEAAM;AACpC,+CAA+C,kGAAuB;AACtE,mCAAmC,0EAAW;AAC9C,kCAAkC,wEAAU;AAC5C,wCAAwC,oFAAgB;AACxD,iDAAiD,sGAAyB;AAC1E,+BAA+B,kEAAO;AACtC,mCAAmC,0EAAW;AAC9C,yCAAyC,sFAAiB;AAC1D,yCAAyC,sFAAiB;AAC1D,sCAAsC,gFAAc;AACpD,iDAAiD,sGAAyB;AAC1E,6CAA6C,8FAAqB;AAClE,gCAAgC,oEAAQ;AACxC,iCAAiC,sEAAS;AAC1C,oCAAoC,4EAAY;AAChD,4BAA4B,oEAAQ;AACpC,gDAAgD,oGAAwB;AACxE;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;ACrEO;AACA;AACP,iC;;;;;;;;;;;;;;;;;;;ACFkD;AACZ;AACF;AAC7B,kCAAkC,+CAAS;AAClD,kBAAkB,yDAAyD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iDAAM,MAAM;AAC5D;AACA,6BAA6B,OAAO;AACpC,2BAA2B,KAAK;AAChC,wCAAwC,iBAAiB;AACzD,iCAAiC,UAAU;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACO,mDAAmD,+CAAS;AACnE,kBAAkB,aAAa;AAC/B;AACA;AACA,gCAAgC,iDAAM,MAAM;AAC5C,6BAA6B,8DAAS,SAAS;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACO,gDAAgD,+CAAS;AAChE,kBAAkB,YAAY;AAC9B;AACA;AACA,qCAAqC,GAAG;AACxC,kDAAkD,OAAO;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACyb;AACjY;AACgC;AACnB;AACC;AACJ;AACI;AACN;AACJ;AACI;AACW;AAClB;AACiB;AACrB;AACU;AAG6C;AAC3C;AACjB;AAG4D;AACq9B;AACngC;AACQ;AACwrB;AACnsB;AACE;AACL;AACD;AACsG;AACmD;AACnH;AAC6D;AACF;AACnF;AACwC;AAC9C;AACgP;AAC9K;AAC6kB;AACzmB;AACoP;AAC/R;AACmD;AAC/C;AACmB;AACP;AACN;AACE;AACN;AACQ;AACI;AACF;AACN;AACE;AACA;AACE;AACI;AAChB;AACJ;AACQ;AACsB;AACT;AACoC;AACvD;AACU;AACK;AACV;AAC8B;AACN;AAChC;AACgC;AACtB;AACd;AAGgE;AACzC;AACf;AACG;AACsB;AACX;AACvB;AACJ;AACe;AACjB;AACyB;AACxB;AACwE;AACZ;AAClD;AACuD;AACV;AAC3B;AACpB;AACF;AACK;AACe;AACC;AAClB;AACqD;AACI;AACoB;AACnF;AACO;AACA;AACN;AACU;AAGmB;AAGG;AAChB;AAGsB;AAGG;AACpC;AACF;AACwB;AACnB;AACC;AACI;AACkC;AAChC;AAC4B;AACd;AACA;AAG6C;AACvC;AACA;AAGW;AACzB;AACc;AACV;AACkB;AACJ;AAG+C;AAC3C;AACA;AAGe;AACX;AACpB;AACd;AACM;AACI;AACvB;AACqB;AACkE;AACpC;AACpB;AACJ;AACM;AACE;AACoC;AAC7D;AACF;AACE;AACF;AACH;AACG;AACzD,iC;;;;;;;;;;;;;;AChLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;ACnBsG;AACtC;AAChE;AACO;AACP,YAAY,sBAAsB;AAClC;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB,uEAA2B,GAAG,UAAU;AAC1D;AACA,kBAAkB,6EAAiC,GAAG,UAAU;AAChE;AACA,kBAAkB,6EAAiC,GAAG,UAAU;AAChE,iBAAiB,4EAAmB,0BAA0B,2BAA2B;AACzF,aAAa;AACb;AACA,4C;;;;;;;;;;;;;;;;;;;;;;;;ACjB2C;AACE;AACR;AACI;AACQ;AACJ;AACI;AACJ;AACtC;AACP;AACA;AACA;AACA;AACO;AACP,iBAAiB,6DAAO,CAAC,0DAAU;AACnC,gBAAgB,6DAAO;AACvB;AACA;AACA,WAAW,0DAAU,MAAM,6DAAS,CAAC,yDAAK,oCAAoC;AAC9E;AACO;AACP,iBAAiB,6DAAO,CAAC,0DAAU;AACnC,iBAAiB,iDAAG,CAAC,yDAAO,0BAA0B,6DAAO;AAC7D;AACA,KAAK;AACL;AACA;AACA,gBAAgB,yDAAO;AACvB;AACA,mBAAmB,6DAAO;AAC1B;AACA,eAAe,6DAAS;AACxB,KAAK;AACL,WAAW,0DAAU,CAAC,qDAAK,CAAC,6DAAS,CAAC,uDAAM,EAAE,6DAAO;AACrD;AACA,8C;;;;;;;;;;;;;;;;;ACnC4C;AACQ;AACF;AAC3C;AACP;AACA;AACA,sCAAsC,gEAAU;AAChD;AACA;AACA,iBAAiB,wDAAY;AAC7B;AACA;AACA,uBAAuB,wDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAU;AACrC;AACA,qC;;;;;;;;;;;;;;;ACjC4E;AAC5E;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAyD;AACrE;AACA,qCAAqC,kCAAkC;AACvE,uDAAuD,UAAU;AACjE;AACA;AACO;AACP,YAAY,oBAAoB;AAChC;AACA;AACA,iBAAiB,aAAa;AAC9B,oBAAoB,wFAAyB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qD;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBiD;AACiF;AACzE;AACM;AACI;AACN;AACnB;AACF;AAC4D;AACzD;AACpC;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACO,wCAAwC,kCAAkC;AACjF,YAAY,OAAO,EAAE,4EAAiB;AACtC;AACA;AACA,KAAK;AACL;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA,aAAa,0EAAc;AAC3B,sBAAsB,8EAAiC,GAAG,YAAY;AACtE,qCAAqC,kFAAoB;AACzD,oBAAoB,0FAAwB;AAC5C;AACA;AACA,aAAa;AACb,mCAAmC,8BAA8B;AACjE,gBAAgB,cAAc,QAAQ,6DAAI;AAC1C;AACA;AACA,kBAAkB,uDAAM;AACxB;AACA,gBAAgB,gFAAmB,IAAI,eAAe,IAAI,eAAe;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,gEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO,6BAA6B,qBAAqB;AACzD;AACA,oBAAoB,iBAAiB;AACrC;AACA,sCAAsC,KAAK;AAC3C,2CAA2C,eAAe;AAC1D,8CAA8C,qCAAqC;AACnF;AACA,uDAAuD,OAAO,mCAAmC,KAAK;AACtG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAgB;AAC5C;AACA;AACA,0BAA0B,wDAAS;AACnC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,qDAAK;AACtB,4BAA4B,iFAAoC;AAChE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAgB;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;;;ACjIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;ACRO,wBAAwB,aAAa;AAC5C;AACA;AACA,wC;;;;;;;;;;;;;;ACHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;ACTiD;AACgB;AACpB;AACH;AACF;AACjC;AACP;AACA;AACA;AACA,0BAA0B,qEAAoB;AAC9C,mBAAmB,uDAAU;AAC7B;AACA;AACA,KAAK;AACL,mBAAmB,wDAAY;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;AC1D8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,kEAAsB,GAAG,SAAS;AACpD;AACA;AACA,sC;;;;;;;;;;;;;;;;AChByC;AACF;AAChC;AACP,WAAW,qDAAK,UAAU,mDAAI;AAC9B;AACA,kC;;;;;;;;;;;;;;;;;;ACLuE;AAC9B;AACQ;AACJ;AACtC;AACP;AACA,kBAAkB,kEAAe,CAAC,qDAAK,UAAU,eAAe,IAAI,6DAAO;AAC3E;AACA;AACA,WAAW,yDAAK;AAChB;AACA,qC;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;ACpB4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wDAAS;AACpB;AACA,oC;;;;;;;;;;;;;;;;;;ACxB+E;AAC7C;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP,YAAY,SAAS;AACrB;AACA,yBAAyB,2CAAM;AAC/B;AACA,sBAAsB,kBAAkB,QAAQ,QAAQ,GAAG,QAAQ;AACnE;AACA,wBAAwB,0BAA0B;AAClD,iCAAiC,kBAAkB;AACnD,uCAAuC,0BAA0B;AACjE,6BAA6B,kBAAkB;AAC/C;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA,SAAS;AACT,0BAA0B,kBAAkB;AAC5C,iCAAiC,kBAAkB;AACnD;AACA;AACA,SAAS;AACT,oBAAoB,0BAA0B;AAC9C,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,kBAAkB;AAClC,iCAAiC,kBAAkB;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,kBAAkB;AACtC,mBAAmB,2FAAmB;AACtC;AACA;AACA,aAAa;AACb,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,CAAC;AACD,wC;;;;;;;;;;;;;;;;ACnFoD;AACF;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,iBAAiB;AAC/D,8BAA8B,gEAAU;AACxC;AACA;AACA;AACA;AACA,aAAa,MAAM,8DAAU;AAC7B;AACA,uD;;;;;;;;;;;;;;;;AC3B6D;AACjB;AAC5C;AACO;AACP,WAAW,wDAAQ,qBAAqB,kEAAiB;AACzD;AACA,8C;;;;;;;;;;;;;;;ACN8C;AAC9C;AACO;AACP,WAAW,gDAAyB;AACpC;AACA,8C;;;;;;;;;;;;;;;;ACLoD;AACD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACO;AACP,YAAY,OAAO,EAAE,8DAAS;AAC9B;AACA,WAAW,+DAAW,MAAM,UAAU;AACtC,qBAAqB,+DAAW,MAAM,UAAU;AAChD;AACA;AACA,iD;;;;;;;;;;;;;;;;ACnBqE;AACP;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACO;AACP,SAAS,0EAAkB;AAC3B,iBAAiB;AACjB,wCAAwC,gFAAmB,IAAI,iBAAiB,IAAI,eAAe,IAAI,eAAe;AACtH,aAAa;AACb;AACA,iD;;;;;;;;;;;;;;;;;ACnB8C;AACK;AACW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,0EAAkB;AAC3B,iBAAiB;AACjB,YAAY,+CAA+C,EAAE,8CAAuB;AACpF;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAW,uBAAuB,UAAU;AAC3D,eAAe,+DAAW,uBAAuB,UAAU;AAC3D;AACA,SAAS;AACT,mBAAmB,cAAc,IAAI;AACrC;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;AC3B+C;AACO;AAC/C,uCAAuC,qBAAqB;AACnE,WAAW,kEAAc,GAAG,MAAM,4DAAW,sBAAsB;AACnE;AACA,iD;;;;;;;;;;;;;;;;;;ACLiD;AACqB;AACS;AACzB;AAC/C;AACP,YAAY,+CAA+C;AAC3D,wBAAwB,kFAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0FAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,kEAAc;AAC/B,cAAc,6DAAS;AACvB;AACA,KAAK;AACL;AACA,qD;;;;;;;;;;;;;;;;AC1BmD;AACG;AAC/C;AACP,YAAY,iDAAiD;AAC7D,WAAW,kEAAc;AACzB,cAAc,gEAAa;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,mD;;;;;;;;;;;;;;;;ACdoD;AACC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO,qCAAqC,iBAAiB;AAC7D,gBAAgB,IAAI,8DAAS,WAAW,iEAAW,KAAK,iEAAW,8BAA8B;AACjG;AACA,qD;;;;;;;;;;;;;;;;;;AClB6D;AACO;AACtB;AACM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACO;AACP,YAAY,uCAAuC;AACnD,uBAAuB,0DAAS;AAChC,QAAQ,gFAAmB,IAAI,iBAAiB,IAAI,eAAe,IAAI,eAAe;AACtF,QAAQ,kEAAiB;AACzB;AACA;AACA;AACA,WAAW,gEAAU;AACrB;AACA,qD;;;;;;;;;;;;;;;;ACxB8C;AACM;AACpD;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,uCAAuC;AACnD,uBAAuB,4CAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,gEAAU;AACrB;AACA,qD;;;;;;;;;;;;;;;;AC3BoD;AACF;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,sBAAsB,gEAAU;AAChC;AACA,sBAAsB,8DAAU;AAChC;AACA,aAAa;AACb;AACA,uD;;;;;;;;;;;;;;;;;AC9BsD;AACS;AACT;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wBAAwB;AACxB,oDAAoD;AACpD;AACO,4BAA4B,2BAA2B;AAC9D,WAAW,0EAAc,CAAC,kEAAU,iBAAiB,kEAAc,GAAG,iBAAiB;AACvF;AACA,sC;;;;;;;;;;;;;;;;;AClBsD;AACS;AACK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wBAAwB;AACxB,oDAAoD;AACpD;AACO,+BAA+B,8BAA8B;AACpE,WAAW,0EAAc,CAAC,kEAAU,iBAAiB,gFAAqB,GAAG,oBAAoB;AACjG;AACA,yC;;;;;;;;;;;;;;;;;AClBsD;AACS;AACS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wBAAwB;AACxB,oDAAoD;AACpD;AACO;AACP,YAAY,0DAA0D;AACtE,WAAW,0EAAc,CAAC,kEAAU,iBAAiB,oFAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2C;;;;;;;;;;;;;;;;;ACzBqF;AACzC;AACS;AAC9C;AACP,2BAA2B,wDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iEAAW;AAC9C;AACA,cAAc,yFAAqC,GAAG,gBAAgB;AACtE;AACA,wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjB+D;AACuC;AAClD;AACO;AAClB;AACD;AACD;AAC4B;AAClB;AACN;AAC+H;AACxF;AAC3E;AACP,iBAAiB,+FAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,iBAAiB,iEAAW;AAC5B;AACA;AACA,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,0BAA0B,iEAAW;AACrC,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,iDAAiD,iEAAW;AAC5D,QAAQ,qDAAK;AACb,4BAA4B,iEAAW;AACvC,QAAQ,qDAAK;AACb,mCAAmC,iEAAW;AAC9C,QAAQ,qDAAK;AACb,2CAA2C,iEAAW;AACtD;AACA;AACA;AACA;AACA,IAAI,gFAAwB;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,iEAAW;AAC5B;AACA;AACA;AACA,QAAQ,qDAAK;AACb,0BAA0B,iEAAW;AACrC,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,iDAAiD,iEAAW;AAC5D,QAAQ,qDAAK;AACb,4BAA4B,iEAAW;AACvC,QAAQ,qDAAK;AACb,uCAAuC,iEAAW;AAClD,QAAQ,qDAAK;AACb,mCAAmC,iEAAW;AAC9C,QAAQ,qDAAK;AACb,2CAA2C,iEAAW;AACtD;AACA;AACA;AACA,+BAA+B,uEAAc;AAC7C;AACA;AACA;AACA,SAAS;AACT,IAAI,gFAAwB;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,iBAAiB,iEAAW;AAC5B;AACA;AACA,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,0BAA0B,iEAAW;AACrC,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,iDAAiD,iEAAW;AAC5D,QAAQ,qDAAK;AACb,4BAA4B,iEAAW;AACvC,QAAQ,qDAAK;AACb,mCAAmC,iEAAW;AAC9C,QAAQ,qDAAK;AACb,2CAA2C,iEAAW;AACtD;AACA;AACA,IAAI,gFAAwB;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,iBAAiB,iEAAW;AAC5B;AACA;AACA,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,0BAA0B,iEAAW;AACrC,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,iDAAiD,iEAAW;AAC5D,QAAQ,qDAAK;AACb,4BAA4B,iEAAW;AACvC,QAAQ,qDAAK;AACb,+BAA+B,iEAAW;AAC1C;AACA;AACA,IAAI,gFAAwB;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,6DAAO;AACpC;AACA;AACA,kBAAkB,qFAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,0BAA0B,iEAAW;AACrC,QAAQ,qDAAK;AACb;AACA,QAAQ,qDAAK;AACb,iDAAiD,iEAAW;AAC5D,QAAQ,qDAAK;AACb,4BAA4B,iEAAW;AACvC,QAAQ,qDAAK;AACb,+BAA+B,iEAAW;AAC1C,IAAI,+EAAuB;AAC3B;AACA;AACA,uBAAuB,qDAAK;AAC5B,UAAU,iEAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAmB,GAAG,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,6DAAO,MAAM,+BAA+B;AACvD;AACO;AACP;AACA,oBAAoB,wBAAwB;AAC5C;AACA,aAAa,gEAAS,YAAY,eAAe;AACjD,sBAAsB,mEAAmB,GAAG,SAAS;AACrD;AACA;AACA,mDAAmD,uDAAM,cAAc,mDAAI;AAC3E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA,4CAA4C,iEAAW;AACvD,wCAAwC,iEAAW;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAW;AAClD;AACA,WAAW,oDAAM,iBAAiB,UAAU;AAC5C,WAAW,oDAAM,iBAAiB,UAAU;AAC5C;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;AC5VqD;AACR;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAU,QAAQ,0DAAU;AACvC;AACA,sC;;;;;;;;;;;;;;;;AChBoD;AACP;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAU,QAAQ,yDAAS;AACtC;AACA,qC","sources":["webpack://DuckHunt-JS/./node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/dropTransaction.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/dumpState.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/getAutomine.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/getTxpoolContent.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/getTxpoolStatus.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/impersonateAccount.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/increaseTime.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/inspectTxpool.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/loadState.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/mine.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/removeBlockTimestampInterval.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/reset.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/revert.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/sendUnsignedTransaction.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setAutomine.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setBalance.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setBlockGasLimit.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setBlockTimestampInterval.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setCode.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setCoinbase.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setIntervalMining.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setLoggingEnabled.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setMinGasPrice.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setNextBlockBaseFeePerGas.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setNextBlockTimestamp.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setNonce.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setRpcUrl.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/setStorageAt.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/snapshot.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/actions/test/stopImpersonatingAccount.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/clients/createTestClient.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/clients/decorators/test.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/constants/bytes.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/errors/ccip.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/index.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/types/eip1193.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/abi/decodeDeployData.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/address/getContractAddress.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/blob/fromBlobs.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/blob/sidecarsToVersionedHashes.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/ccip.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/chain/defineChain.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/chain/extractChain.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/data/isBytes.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/encoding/fromRlp.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/ens/toCoinType.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/hash/isHash.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/hash/ripemd160.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/kzg/defineKzg.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/kzg/setupKzg.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/nonceManager.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/compactSignatureToSignature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/isErc6492Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/isErc8010Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/parseCompactSignature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/parseErc6492Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/parseErc8010Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/recoverMessageAddress.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/recoverTransactionAddress.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/serializeCompactSignature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/serializeErc8010Signature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/signatureToCompactSignature.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/verifyHash.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/verifyMessage.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/signature/verifyTypedData.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/transaction/getSerializedTransactionType.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/transaction/parseTransaction.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/unit/parseEther.js","webpack://DuckHunt-JS/./node_modules/viem/_esm/utils/unit/parseGwei.js"],"sourcesContent":["import { InvalidAbiParameterError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter(param) {\n    let abiParameter;\n    if (typeof param === 'string')\n        abiParameter = parseAbiParameter_(param, {\n            modifiers,\n        });\n    else {\n        const structs = parseStructs(param);\n        const length = param.length;\n        for (let i = 0; i < length; i++) {\n            const signature = param[i];\n            if (isStructSignature(signature))\n                continue;\n            abiParameter = parseAbiParameter_(signature, { modifiers, structs });\n            break;\n        }\n    }\n    if (!abiParameter)\n        throw new InvalidAbiParameterError({ param });\n    return abiParameter;\n}\n//# sourceMappingURL=parseAbiParameter.js.map","/**\n * Removes a transaction from the mempool.\n *\n * - Docs: https://viem.sh/docs/actions/test/dropTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link DropTransactionParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { dropTransaction } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await dropTransaction(client, {\n *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'\n * })\n */\nexport async function dropTransaction(client, { hash }) {\n    await client.request({\n        method: `${client.mode}_dropTransaction`,\n        params: [hash],\n    });\n}\n//# sourceMappingURL=dropTransaction.js.map","/**\n * Serializes the current state (including contracts code, contract's storage,\n * accounts properties, etc.) into a savable data blob.\n *\n * - Docs: https://viem.sh/docs/actions/test/dumpState\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { dumpState } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await dumpState(client)\n */\nexport async function dumpState(client) {\n    return client.request({\n        method: `${client.mode}_dumpState`,\n    });\n}\n//# sourceMappingURL=dumpState.js.map","/**\n * Returns the automatic mining status of the node.\n *\n * - Docs: https://viem.sh/docs/actions/test/getAutomine\n *\n * @param client - Client to use\n * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getAutomine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const isAutomining = await getAutomine(client)\n */\nexport async function getAutomine(client) {\n    if (client.mode === 'ganache')\n        return await client.request({\n            method: 'eth_mining',\n        });\n    return await client.request({\n        method: `${client.mode}_getAutomine`,\n    });\n}\n//# sourceMappingURL=getAutomine.js.map","/**\n * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent\n *\n * @param client - Client to use\n * @returns Transaction pool content. {@link GetTxpoolContentReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getTxpoolContent } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const content = await getTxpoolContent(client)\n */\nexport async function getTxpoolContent(client) {\n    return await client.request({\n        method: 'txpool_content',\n    });\n}\n//# sourceMappingURL=getTxpoolContent.js.map","import { hexToNumber } from '../../utils/encoding/fromHex.js';\n/**\n * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus\n *\n * @param client - Client to use\n * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getTxpoolStatus } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const status = await getTxpoolStatus(client)\n */\nexport async function getTxpoolStatus(client) {\n    const { pending, queued } = await client.request({\n        method: 'txpool_status',\n    });\n    return {\n        pending: hexToNumber(pending),\n        queued: hexToNumber(queued),\n    };\n}\n//# sourceMappingURL=getTxpoolStatus.js.map","/**\n * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.\n *\n * - Docs: https://viem.sh/docs/actions/test/impersonateAccount\n *\n * @param client - Client to use\n * @param parameters - {@link ImpersonateAccountParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { impersonateAccount } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const content = await impersonateAccount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function impersonateAccount(client, { address }) {\n    await client.request({\n        method: `${client.mode}_impersonateAccount`,\n        params: [address],\n    });\n}\n//# sourceMappingURL=impersonateAccount.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Jump forward in time by the given amount of time, in seconds.\n *\n * - Docs: https://viem.sh/docs/actions/test/increaseTime\n *\n * @param client - Client to use\n * @param parameters – {@link IncreaseTimeParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { increaseTime } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await increaseTime(client, {\n *   seconds: 420,\n * })\n */\nexport async function increaseTime(client, { seconds }) {\n    return await client.request({\n        method: 'evm_increaseTime',\n        params: [numberToHex(seconds)],\n    });\n}\n//# sourceMappingURL=increaseTime.js.map","/**\n * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/inspectTxpool\n *\n * @param client - Client to use\n * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { inspectTxpool } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const data = await inspectTxpool(client)\n */\nexport async function inspectTxpool(client) {\n    return await client.request({\n        method: 'txpool_inspect',\n    });\n}\n//# sourceMappingURL=inspectTxpool.js.map","/**\n * Adds state previously dumped with `dumpState` to the current chain.\n *\n * - Docs: https://viem.sh/docs/actions/test/loadState\n *\n * @param client - Client to use\n * @param parameters - {@link LoadStateParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { loadState } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await loadState(client, { state: '0x...' })\n */\nexport async function loadState(client, { state }) {\n    await client.request({\n        method: `${client.mode}_loadState`,\n        params: [state],\n    });\n}\n//# sourceMappingURL=loadState.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Mine a specified number of blocks.\n *\n * - Docs: https://viem.sh/docs/actions/test/mine\n *\n * @param client - Client to use\n * @param parameters – {@link MineParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { mine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await mine(client, { blocks: 1 })\n */\nexport async function mine(client, { blocks, interval }) {\n    if (client.mode === 'ganache')\n        await client.request({\n            method: 'evm_mine',\n            params: [{ blocks: numberToHex(blocks) }],\n        });\n    else\n        await client.request({\n            method: `${client.mode}_mine`,\n            params: [numberToHex(blocks), numberToHex(interval || 0)],\n        });\n}\n//# sourceMappingURL=mine.js.map","/**\n * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.\n *\n * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { removeBlockTimestampInterval } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await removeBlockTimestampInterval(client)\n */\nexport async function removeBlockTimestampInterval(client) {\n    await client.request({\n        method: `${client.mode}_removeBlockTimestampInterval`,\n    });\n}\n//# sourceMappingURL=removeBlockTimestampInterval.js.map","/**\n * Resets fork back to its original state.\n *\n * - Docs: https://viem.sh/docs/actions/test/reset\n *\n * @param client - Client to use\n * @param parameters – {@link ResetParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { reset } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await reset(client, { blockNumber: 69420n })\n */\nexport async function reset(client, { blockNumber, jsonRpcUrl } = {}) {\n    await client.request({\n        method: `${client.mode}_reset`,\n        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],\n    });\n}\n//# sourceMappingURL=reset.js.map","/**\n * Revert the state of the blockchain at the current block.\n *\n * - Docs: https://viem.sh/docs/actions/test/revert\n *\n * @param client - Client to use\n * @param parameters – {@link RevertParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { revert } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await revert(client, { id: '0x…' })\n */\nexport async function revert(client, { id }) {\n    await client.request({\n        method: 'evm_revert',\n        params: [id],\n    });\n}\n//# sourceMappingURL=revert.js.map","import { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\n/**\n * Executes a transaction regardless of the signature.\n *\n * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction#sendunsignedtransaction\n *\n * @param client - Client to use\n * @param parameters – {@link SendUnsignedTransactionParameters}\n * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { sendUnsignedTransaction } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const hash = await sendUnsignedTransaction(client, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendUnsignedTransaction(client, args) {\n    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format({\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        accessList,\n        data,\n        from,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n    }, 'sendUnsignedTransaction');\n    const hash = await client.request({\n        method: 'eth_sendUnsignedTransaction',\n        params: [request],\n    });\n    return hash;\n}\n//# sourceMappingURL=sendUnsignedTransaction.js.map","/**\n * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.\n *\n * - Docs: https://viem.sh/docs/actions/test/setAutomine\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setAutomine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setAutomine(client)\n */\nexport async function setAutomine(client, enabled) {\n    if (client.mode === 'ganache') {\n        if (enabled)\n            await client.request({ method: 'miner_start' });\n        else\n            await client.request({ method: 'miner_stop' });\n    }\n    else\n        await client.request({\n            method: 'evm_setAutomine',\n            params: [enabled],\n        });\n}\n//# sourceMappingURL=setAutomine.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Modifies the balance of an account.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBalance\n *\n * @param client - Client to use\n * @param parameters – {@link SetBalanceParameters}\n *\n * @example\n * import { createTestClient, http, parseEther } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBalance } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBalance(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   value: parseEther('1'),\n * })\n */\nexport async function setBalance(client, { address, value }) {\n    if (client.mode === 'ganache')\n        await client.request({\n            method: 'evm_setAccountBalance',\n            params: [address, numberToHex(value)],\n        });\n    else\n        await client.request({\n            method: `${client.mode}_setBalance`,\n            params: [address, numberToHex(value)],\n        });\n}\n//# sourceMappingURL=setBalance.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Sets the block's gas limit.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit\n *\n * @param client - Client to use\n * @param parameters – {@link SetBlockGasLimitParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBlockGasLimit } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBlockGasLimit(client, { gasLimit: 420_000n })\n */\nexport async function setBlockGasLimit(client, { gasLimit }) {\n    await client.request({\n        method: 'evm_setBlockGasLimit',\n        params: [numberToHex(gasLimit)],\n    });\n}\n//# sourceMappingURL=setBlockGasLimit.js.map","/**\n * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval\n *\n * @param client - Client to use\n * @param parameters – {@link SetBlockTimestampIntervalParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBlockTimestampInterval } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBlockTimestampInterval(client, { interval: 5 })\n */\nexport async function setBlockTimestampInterval(client, { interval }) {\n    const interval_ = (() => {\n        if (client.mode === 'hardhat')\n            return interval * 1000;\n        return interval;\n    })();\n    await client.request({\n        method: `${client.mode}_setBlockTimestampInterval`,\n        params: [interval_],\n    });\n}\n//# sourceMappingURL=setBlockTimestampInterval.js.map","/**\n * Modifies the bytecode stored at an account's address.\n *\n * - Docs: https://viem.sh/docs/actions/test/setCode\n *\n * @param client - Client to use\n * @param parameters – {@link SetCodeParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setCode } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setCode(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739df…',\n * })\n */\nexport async function setCode(client, { address, bytecode }) {\n    if (client.mode === 'ganache')\n        await client.request({\n            method: 'evm_setAccountCode',\n            params: [address, bytecode],\n        });\n    else\n        await client.request({\n            method: `${client.mode}_setCode`,\n            params: [address, bytecode],\n        });\n}\n//# sourceMappingURL=setCode.js.map","/**\n * Sets the coinbase address to be used in new blocks.\n *\n * - Docs: https://viem.sh/docs/actions/test/setCoinbase\n *\n * @param client - Client to use\n * @param parameters – {@link SetCoinbaseParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setCoinbase } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setCoinbase(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n * })\n */\nexport async function setCoinbase(client, { address }) {\n    await client.request({\n        method: `${client.mode}_setCoinbase`,\n        params: [address],\n    });\n}\n//# sourceMappingURL=setCoinbase.js.map","/**\n * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.\n *\n * - Docs: https://viem.sh/docs/actions/test/setIntervalMining\n *\n * @param client - Client to use\n * @param parameters – {@link SetIntervalMiningParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setIntervalMining } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setIntervalMining(client, { interval: 5 })\n */\nexport async function setIntervalMining(client, { interval }) {\n    const interval_ = (() => {\n        if (client.mode === 'hardhat')\n            return interval * 1000;\n        return interval;\n    })();\n    await client.request({\n        method: 'evm_setIntervalMining',\n        params: [interval_],\n    });\n}\n//# sourceMappingURL=setIntervalMining.js.map","/**\n * Enable or disable logging on the test node network.\n *\n * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setLoggingEnabled } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setLoggingEnabled(client)\n */\nexport async function setLoggingEnabled(client, enabled) {\n    await client.request({\n        method: `${client.mode}_setLoggingEnabled`,\n        params: [enabled],\n    });\n}\n//# sourceMappingURL=setLoggingEnabled.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Change the minimum gas price accepted by the network (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice\n *\n * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.\n *\n * @param client - Client to use\n * @param parameters – {@link SetBlockGasLimitParameters}\n *\n * @example\n * import { createTestClient, http, parseGwei } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setMinGasPrice } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setMinGasPrice(client, {\n *   gasPrice: parseGwei('20'),\n * })\n */\nexport async function setMinGasPrice(client, { gasPrice }) {\n    await client.request({\n        method: `${client.mode}_setMinGasPrice`,\n        params: [numberToHex(gasPrice)],\n    });\n}\n//# sourceMappingURL=setMinGasPrice.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Sets the next block's base fee per gas.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas\n *\n * @param client - Client to use\n * @param parameters – {@link SetNextBlockBaseFeePerGasParameters}\n *\n * @example\n * import { createTestClient, http, parseGwei } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNextBlockBaseFeePerGas } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNextBlockBaseFeePerGas(client, {\n *   baseFeePerGas: parseGwei('20'),\n * })\n */\nexport async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {\n    await client.request({\n        method: `${client.mode}_setNextBlockBaseFeePerGas`,\n        params: [numberToHex(baseFeePerGas)],\n    });\n}\n//# sourceMappingURL=setNextBlockBaseFeePerGas.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Sets the next block's timestamp.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp\n *\n * @param client - Client to use\n * @param parameters – {@link SetNextBlockTimestampParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNextBlockTimestamp } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNextBlockTimestamp(client, { timestamp: 1671744314n })\n */\nexport async function setNextBlockTimestamp(client, { timestamp }) {\n    await client.request({\n        method: 'evm_setNextBlockTimestamp',\n        params: [numberToHex(timestamp)],\n    });\n}\n//# sourceMappingURL=setNextBlockTimestamp.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Modifies (overrides) the nonce of an account.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNonce\n *\n * @param client - Client to use\n * @param parameters – {@link SetNonceParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNonce } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNonce(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   nonce: 420,\n * })\n */\nexport async function setNonce(client, { address, nonce }) {\n    await client.request({\n        method: `${client.mode}_setNonce`,\n        params: [address, numberToHex(nonce)],\n    });\n}\n//# sourceMappingURL=setNonce.js.map","/**\n * Sets the backend RPC URL.\n *\n * - Docs: https://viem.sh/docs/actions/test/setRpcUrl\n *\n * @param client - Client to use\n * @param jsonRpcUrl – RPC URL\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setRpcUrl } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setRpcUrl(client, 'https://eth-mainnet.g.alchemy.com/v2')\n */\nexport async function setRpcUrl(client, jsonRpcUrl) {\n    await client.request({\n        method: `${client.mode}_setRpcUrl`,\n        params: [jsonRpcUrl],\n    });\n}\n//# sourceMappingURL=setRpcUrl.js.map","import { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Writes to a slot of an account's storage.\n *\n * - Docs: https://viem.sh/docs/actions/test/setStorageAt\n *\n * @param client - Client to use\n * @param parameters – {@link SetStorageAtParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setStorageAt } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setStorageAt(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n *   index: 2,\n *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',\n * })\n */\nexport async function setStorageAt(client, { address, index, value }) {\n    await client.request({\n        method: `${client.mode}_setStorageAt`,\n        params: [\n            address,\n            typeof index === 'number' ? numberToHex(index) : index,\n            value,\n        ],\n    });\n}\n//# sourceMappingURL=setStorageAt.js.map","/**\n * Snapshot the state of the blockchain at the current block.\n *\n * - Docs: https://viem.sh/docs/actions/test/snapshot\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { snapshot } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await snapshot(client)\n */\nexport async function snapshot(client) {\n    return await client.request({\n        method: 'evm_snapshot',\n    });\n}\n//# sourceMappingURL=snapshot.js.map","/**\n * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).\n *\n * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount\n *\n * @param client - Client to use\n * @param parameters – {@link StopImpersonatingAccountParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { stopImpersonatingAccount } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await stopImpersonatingAccount(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n */\nexport async function stopImpersonatingAccount(client, { address }) {\n    await client.request({\n        method: `${client.mode}_stopImpersonatingAccount`,\n        params: [address],\n    });\n}\n//# sourceMappingURL=stopImpersonatingAccount.js.map","import { createClient, } from './createClient.js';\nimport { testActions } from './decorators/test.js';\nexport function createTestClient(parameters) {\n    const { key = 'test', name = 'Test Client', mode } = parameters;\n    const client = createClient({\n        ...parameters,\n        key,\n        name,\n        type: 'testClient',\n    });\n    return client.extend((config) => ({\n        mode,\n        ...testActions({ mode })(config),\n    }));\n}\n//# sourceMappingURL=createTestClient.js.map","import { dropTransaction, } from '../../actions/test/dropTransaction.js';\nimport { dumpState, } from '../../actions/test/dumpState.js';\nimport { getAutomine, } from '../../actions/test/getAutomine.js';\nimport { getTxpoolContent, } from '../../actions/test/getTxpoolContent.js';\nimport { getTxpoolStatus, } from '../../actions/test/getTxpoolStatus.js';\nimport { impersonateAccount, } from '../../actions/test/impersonateAccount.js';\nimport { increaseTime, } from '../../actions/test/increaseTime.js';\nimport { inspectTxpool, } from '../../actions/test/inspectTxpool.js';\nimport { loadState, } from '../../actions/test/loadState.js';\nimport { mine } from '../../actions/test/mine.js';\nimport { removeBlockTimestampInterval } from '../../actions/test/removeBlockTimestampInterval.js';\nimport { reset } from '../../actions/test/reset.js';\nimport { revert } from '../../actions/test/revert.js';\nimport { sendUnsignedTransaction, } from '../../actions/test/sendUnsignedTransaction.js';\nimport { setAutomine } from '../../actions/test/setAutomine.js';\nimport { setBalance, } from '../../actions/test/setBalance.js';\nimport { setBlockGasLimit, } from '../../actions/test/setBlockGasLimit.js';\nimport { setBlockTimestampInterval, } from '../../actions/test/setBlockTimestampInterval.js';\nimport { setCode } from '../../actions/test/setCode.js';\nimport { setCoinbase, } from '../../actions/test/setCoinbase.js';\nimport { setIntervalMining, } from '../../actions/test/setIntervalMining.js';\nimport { setLoggingEnabled } from '../../actions/test/setLoggingEnabled.js';\nimport { setMinGasPrice, } from '../../actions/test/setMinGasPrice.js';\nimport { setNextBlockBaseFeePerGas, } from '../../actions/test/setNextBlockBaseFeePerGas.js';\nimport { setNextBlockTimestamp, } from '../../actions/test/setNextBlockTimestamp.js';\nimport { setNonce, } from '../../actions/test/setNonce.js';\nimport { setRpcUrl } from '../../actions/test/setRpcUrl.js';\nimport { setStorageAt, } from '../../actions/test/setStorageAt.js';\nimport { snapshot } from '../../actions/test/snapshot.js';\nimport { stopImpersonatingAccount, } from '../../actions/test/stopImpersonatingAccount.js';\nexport function testActions({ mode, }) {\n    return (client_) => {\n        const client = client_.extend(() => ({\n            mode,\n        }));\n        return {\n            dropTransaction: (args) => dropTransaction(client, args),\n            dumpState: () => dumpState(client),\n            getAutomine: () => getAutomine(client),\n            getTxpoolContent: () => getTxpoolContent(client),\n            getTxpoolStatus: () => getTxpoolStatus(client),\n            impersonateAccount: (args) => impersonateAccount(client, args),\n            increaseTime: (args) => increaseTime(client, args),\n            inspectTxpool: () => inspectTxpool(client),\n            loadState: (args) => loadState(client, args),\n            mine: (args) => mine(client, args),\n            removeBlockTimestampInterval: () => removeBlockTimestampInterval(client),\n            reset: (args) => reset(client, args),\n            revert: (args) => revert(client, args),\n            sendUnsignedTransaction: (args) => sendUnsignedTransaction(client, args),\n            setAutomine: (args) => setAutomine(client, args),\n            setBalance: (args) => setBalance(client, args),\n            setBlockGasLimit: (args) => setBlockGasLimit(client, args),\n            setBlockTimestampInterval: (args) => setBlockTimestampInterval(client, args),\n            setCode: (args) => setCode(client, args),\n            setCoinbase: (args) => setCoinbase(client, args),\n            setIntervalMining: (args) => setIntervalMining(client, args),\n            setLoggingEnabled: (args) => setLoggingEnabled(client, args),\n            setMinGasPrice: (args) => setMinGasPrice(client, args),\n            setNextBlockBaseFeePerGas: (args) => setNextBlockBaseFeePerGas(client, args),\n            setNextBlockTimestamp: (args) => setNextBlockTimestamp(client, args),\n            setNonce: (args) => setNonce(client, args),\n            setRpcUrl: (args) => setRpcUrl(client, args),\n            setStorageAt: (args) => setStorageAt(client, args),\n            snapshot: () => snapshot(client),\n            stopImpersonatingAccount: (args) => stopImpersonatingAccount(client, args),\n        };\n    };\n}\n//# sourceMappingURL=test.js.map","export const erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\nexport const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';\n//# sourceMappingURL=bytes.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n            name: 'OffchainLookupError',\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n            name: 'OffchainLookupResponseMalformedError',\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n            name: 'OffchainLookupSenderMismatchError',\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport { CircularReferenceError, InvalidAbiItemError, InvalidAbiParameterError, InvalidAbiParametersError, InvalidAbiTypeParameterError, InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, InvalidParenthesisError, InvalidSignatureError, InvalidStructSignatureError, parseAbi, parseAbiItem, parseAbiParameter, parseAbiParameters, SolidityProtectedKeywordError, UnknownSignatureError, UnknownTypeError, } from 'abitype';\nexport { getContract, } from './actions/getContract.js';\nexport { WaitForCallsStatusTimeoutError } from './actions/wallet/waitForCallsStatus.js';\nexport { createClient, rpcSchema, } from './clients/createClient.js';\nexport { createPublicClient, } from './clients/createPublicClient.js';\nexport { createTestClient, } from './clients/createTestClient.js';\nexport { createWalletClient, } from './clients/createWalletClient.js';\nexport { publicActions, } from './clients/decorators/public.js';\nexport { testActions, } from './clients/decorators/test.js';\nexport { walletActions, } from './clients/decorators/wallet.js';\nexport { createTransport, } from './clients/transports/createTransport.js';\nexport { custom, } from './clients/transports/custom.js';\nexport { fallback, shouldThrow, } from './clients/transports/fallback.js';\nexport { http, } from './clients/transports/http.js';\nexport { webSocket, } from './clients/transports/webSocket.js';\nexport { erc20Abi, erc20Abi_bytes32, erc721Abi, erc1155Abi, erc4626Abi, erc6492SignatureValidatorAbi, \n/** @deprecated use `erc6492SignatureValidatorAbi` instead. */\nerc6492SignatureValidatorAbi as universalSignatureValidatorAbi, multicall3Abi, } from './constants/abis.js';\nexport { ethAddress, zeroAddress } from './constants/address.js';\nexport { zeroHash } from './constants/bytes.js';\nexport { deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode, erc6492SignatureValidatorByteCode, \n/** @deprecated use `erc6492SignatureValidatorByteCode` instead. */\nerc6492SignatureValidatorByteCode as universalSignatureValidatorByteCode, } from './constants/contracts.js';\nexport { maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, } from './constants/number.js';\nexport { presignMessagePrefix } from './constants/strings.js';\nexport { etherUnits, gweiUnits, weiUnits } from './constants/unit.js';\nexport { AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeInvalidError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorInputsNotFoundError, AbiErrorNotFoundError, AbiErrorSignatureNotFoundError, AbiEventNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiFunctionSignatureNotFoundError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiDecodingTypeError, InvalidAbiEncodingTypeError, InvalidArrayError, InvalidDefinitionTypeError, UnsupportedPackedAbiType, } from './errors/abi.js';\nexport { InvalidAddressError, } from './errors/address.js';\nexport { BaseError, setErrorConfig } from './errors/base.js';\nexport { BlockNotFoundError, } from './errors/block.js';\nexport { BundleFailedError, } from './errors/calls.js';\nexport { ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError, } from './errors/chain.js';\nexport { CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError, } from './errors/contract.js';\nexport { SizeExceedsPaddingSizeError, SliceOffsetOutOfBoundsError, } from './errors/data.js';\nexport { IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, InvalidHexValueError, SizeOverflowError, } from './errors/encoding.js';\nexport { EnsAvatarInvalidNftUriError, EnsAvatarUnsupportedNamespaceError, EnsAvatarUriResolutionError, EnsInvalidChainIdError, } from './errors/ens.js';\nexport { EstimateGasExecutionError, } from './errors/estimateGas.js';\nexport { BaseFeeScalarError, Eip1559FeesNotSupportedError, MaxFeePerGasTooLowError, } from './errors/fee.js';\nexport { FilterTypeNotSupportedError, } from './errors/log.js';\nexport { ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, NonceMaxValueError, NonceTooHighError, NonceTooLowError, TipAboveFeeCapError, TransactionTypeNotSupportedError, UnknownNodeError, } from './errors/node.js';\nexport { HttpRequestError, RpcRequestError, SocketClosedError, TimeoutError, WebSocketRequestError, } from './errors/request.js';\nexport { AtomicityNotSupportedError, AtomicReadyWalletRejectedUpgradeError, BundleTooLargeError, ChainDisconnectedError, DuplicateIdError, InternalRpcError, InvalidInputRpcError, InvalidParamsRpcError, InvalidRequestRpcError, JsonRpcVersionUnsupportedError, LimitExceededRpcError, MethodNotFoundRpcError, MethodNotSupportedRpcError, ParseRpcError, ProviderDisconnectedError, ProviderRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, RpcError, SwitchChainError, TransactionRejectedRpcError, UnauthorizedProviderError, UnknownBundleIdError, UnknownRpcError, UnsupportedChainIdError, UnsupportedNonOptionalCapabilityError, UnsupportedProviderMethodError, UserRejectedRequestError, } from './errors/rpc.js';\nexport { AccountStateConflictError, StateAssignmentConflictError, } from './errors/stateOverride.js';\nexport { FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidSerializedTransactionError, InvalidSerializedTransactionTypeError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError, } from './errors/transaction.js';\nexport { UrlRequiredError, } from './errors/transport.js';\nexport { InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError, } from './errors/typedData.js';\nexport { InvalidDecimalNumberError, } from './errors/unit.js';\nexport { ProviderRpcError as EIP1193ProviderRpcError } from './types/eip1193.js';\nexport { decodeAbiParameters, } from './utils/abi/decodeAbiParameters.js';\nexport { decodeDeployData, } from './utils/abi/decodeDeployData.js';\nexport { decodeErrorResult, } from './utils/abi/decodeErrorResult.js';\nexport { decodeEventLog, } from './utils/abi/decodeEventLog.js';\nexport { decodeFunctionData, } from './utils/abi/decodeFunctionData.js';\nexport { decodeFunctionResult, } from './utils/abi/decodeFunctionResult.js';\nexport { encodeAbiParameters, } from './utils/abi/encodeAbiParameters.js';\nexport { encodeDeployData, } from './utils/abi/encodeDeployData.js';\nexport { encodeErrorResult, } from './utils/abi/encodeErrorResult.js';\nexport { encodeEventTopics, } from './utils/abi/encodeEventTopics.js';\nexport { encodeFunctionData, } from './utils/abi/encodeFunctionData.js';\nexport { encodeFunctionResult, } from './utils/abi/encodeFunctionResult.js';\nexport { encodePacked, } from './utils/abi/encodePacked.js';\nexport { getAbiItem, } from './utils/abi/getAbiItem.js';\nexport { parseEventLogs, } from './utils/abi/parseEventLogs.js';\nexport { prepareEncodeFunctionData, } from './utils/abi/prepareEncodeFunctionData.js';\nexport { checksumAddress, getAddress, } from './utils/address/getAddress.js';\nexport { getContractAddress, getCreate2Address, getCreateAddress, } from './utils/address/getContractAddress.js';\nexport { isAddress, } from './utils/address/isAddress.js';\nexport { isAddressEqual, } from './utils/address/isAddressEqual.js';\nexport { blobsToCommitments, } from './utils/blob/blobsToCommitments.js';\nexport { blobsToProofs, } from './utils/blob/blobsToProofs.js';\nexport { commitmentsToVersionedHashes, } from './utils/blob/commitmentsToVersionedHashes.js';\nexport { commitmentToVersionedHash, } from './utils/blob/commitmentToVersionedHash.js';\nexport { fromBlobs, } from './utils/blob/fromBlobs.js';\nexport { sidecarsToVersionedHashes, } from './utils/blob/sidecarsToVersionedHashes.js';\nexport { toBlobSidecars, } from './utils/blob/toBlobSidecars.js';\nexport { toBlobs, } from './utils/blob/toBlobs.js';\nexport { ccipRequest, \n/** @deprecated Use `ccipRequest`. */\nccipRequest as ccipFetch, offchainLookup, offchainLookupAbiItem, offchainLookupSignature, } from './utils/ccip.js';\nexport { assertCurrentChain, } from './utils/chain/assertCurrentChain.js';\nexport { defineChain } from './utils/chain/defineChain.js';\nexport { extractChain, } from './utils/chain/extractChain.js';\nexport { getChainContractAddress, } from './utils/chain/getChainContractAddress.js';\nexport { concat, concatBytes, concatHex, } from './utils/data/concat.js';\nexport { isBytes } from './utils/data/isBytes.js';\nexport { isHex } from './utils/data/isHex.js';\nexport { pad, padBytes, padHex, } from './utils/data/pad.js';\nexport { size } from './utils/data/size.js';\nexport { slice, sliceBytes, sliceHex, } from './utils/data/slice.js';\nexport { trim, } from './utils/data/trim.js';\nexport { bytesToBigInt, bytesToBool, bytesToNumber, bytesToString, fromBytes, } from './utils/encoding/fromBytes.js';\nexport { fromHex, hexToBigInt, hexToBool, hexToNumber, hexToString, } from './utils/encoding/fromHex.js';\nexport { fromRlp, } from './utils/encoding/fromRlp.js';\nexport { boolToBytes, hexToBytes, numberToBytes, stringToBytes, toBytes, } from './utils/encoding/toBytes.js';\nexport { boolToHex, bytesToHex, numberToHex, stringToHex, toHex, } from './utils/encoding/toHex.js';\nexport { bytesToRlp, hexToRlp, toRlp, } from './utils/encoding/toRlp.js';\nexport { labelhash } from './utils/ens/labelhash.js';\nexport { namehash } from './utils/ens/namehash.js';\nexport { toCoinType, } from './utils/ens/toCoinType.js';\nexport { getContractError, } from './utils/errors/getContractError.js';\nexport { defineBlock, formatBlock, } from './utils/formatters/block.js';\nexport { formatLog } from './utils/formatters/log.js';\nexport { defineTransaction, formatTransaction, transactionType, } from './utils/formatters/transaction.js';\nexport { defineTransactionReceipt, formatTransactionReceipt, } from './utils/formatters/transactionReceipt.js';\nexport { defineTransactionRequest, formatTransactionRequest, rpcTransactionType, } from './utils/formatters/transactionRequest.js';\nexport { isHash } from './utils/hash/isHash.js';\nexport { keccak256, } from './utils/hash/keccak256.js';\nexport { ripemd160, } from './utils/hash/ripemd160.js';\nexport { sha256, } from './utils/hash/sha256.js';\nexport { toEventHash, } from './utils/hash/toEventHash.js';\nexport { toEventSelector, \n/** @deprecated use `toEventSelector`. */\ntoEventSelector as getEventSelector, } from './utils/hash/toEventSelector.js';\nexport { toEventSignature, \n/** @deprecated use `toEventSignature`. */\ntoEventSignature as getEventSignature, } from './utils/hash/toEventSignature.js';\nexport { toFunctionHash, } from './utils/hash/toFunctionHash.js';\nexport { toFunctionSelector, \n/** @deprecated use `toFunctionSelector`. */\ntoFunctionSelector as getFunctionSelector, } from './utils/hash/toFunctionSelector.js';\nexport { toFunctionSignature, \n/** @deprecated use `toFunctionSignature`. */\ntoFunctionSignature as getFunctionSignature, } from './utils/hash/toFunctionSignature.js';\nexport { defineKzg, } from './utils/kzg/defineKzg.js';\nexport { setupKzg, } from './utils/kzg/setupKzg.js';\nexport { createNonceManager, nonceManager, } from './utils/nonceManager.js';\nexport { withCache } from './utils/promise/withCache.js';\nexport { withRetry, } from './utils/promise/withRetry.js';\nexport { withTimeout, } from './utils/promise/withTimeout.js';\nexport { compactSignatureToSignature, } from './utils/signature/compactSignatureToSignature.js';\nexport { hashMessage, } from './utils/signature/hashMessage.js';\nexport { hashDomain, hashStruct, hashTypedData, } from './utils/signature/hashTypedData.js';\nexport { isErc6492Signature, } from './utils/signature/isErc6492Signature.js';\nexport { isErc8010Signature, } from './utils/signature/isErc8010Signature.js';\nexport { \n/** @deprecated Use `parseCompactSignature`. */\nparseCompactSignature as hexToCompactSignature, parseCompactSignature, } from './utils/signature/parseCompactSignature.js';\nexport { parseErc6492Signature, } from './utils/signature/parseErc6492Signature.js';\nexport { parseErc8010Signature, } from './utils/signature/parseErc8010Signature.js';\nexport { \n/** @deprecated Use `parseSignature`. */\nparseSignature as hexToSignature, parseSignature, } from './utils/signature/parseSignature.js';\nexport { recoverAddress, } from './utils/signature/recoverAddress.js';\nexport { recoverMessageAddress, } from './utils/signature/recoverMessageAddress.js';\nexport { recoverPublicKey, } from './utils/signature/recoverPublicKey.js';\nexport { recoverTransactionAddress, } from './utils/signature/recoverTransactionAddress.js';\nexport { recoverTypedDataAddress, } from './utils/signature/recoverTypedDataAddress.js';\nexport { \n/** @deprecated Use `serializeCompactSignature` instead. */\nserializeCompactSignature as compactSignatureToHex, serializeCompactSignature, } from './utils/signature/serializeCompactSignature.js';\nexport { serializeErc6492Signature, } from './utils/signature/serializeErc6492Signature.js';\nexport { serializeErc8010Signature, } from './utils/signature/serializeErc8010Signature.js';\nexport { \n/** @deprecated Use `serializeSignature` instead. */\nserializeSignature as signatureToHex, serializeSignature, } from './utils/signature/serializeSignature.js';\nexport { signatureToCompactSignature, } from './utils/signature/signatureToCompactSignature.js';\nexport { toPrefixedMessage, } from './utils/signature/toPrefixedMessage.js';\nexport { verifyHash, } from './utils/signature/verifyHash.js';\nexport { verifyMessage, } from './utils/signature/verifyMessage.js';\nexport { verifyTypedData, } from './utils/signature/verifyTypedData.js';\nexport { stringify } from './utils/stringify.js';\nexport { assertRequest, } from './utils/transaction/assertRequest.js';\nexport { assertTransactionEIP1559, assertTransactionEIP2930, assertTransactionLegacy, } from './utils/transaction/assertTransaction.js';\nexport { getSerializedTransactionType, } from './utils/transaction/getSerializedTransactionType.js';\nexport { getTransactionType, } from './utils/transaction/getTransactionType.js';\nexport { parseTransaction, } from './utils/transaction/parseTransaction.js';\nexport { serializeAccessList, } from './utils/transaction/serializeAccessList.js';\nexport { serializeTransaction, } from './utils/transaction/serializeTransaction.js';\nexport { domainSeparator, getTypesForEIP712Domain, serializeTypedData, validateTypedData, } from './utils/typedData.js';\nexport { formatEther, } from './utils/unit/formatEther.js';\nexport { formatGwei, } from './utils/unit/formatGwei.js';\nexport { formatUnits, } from './utils/unit/formatUnits.js';\nexport { parseEther, } from './utils/unit/parseEther.js';\nexport { parseGwei } from './utils/unit/parseGwei.js';\nexport { parseUnits, } from './utils/unit/parseUnits.js';\n//# sourceMappingURL=index.js.map","export class ProviderRpcError extends Error {\n    constructor(code, message) {\n        super(message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.code = code;\n        this.details = message;\n    }\n}\n//# sourceMappingURL=eip1193.js.map","import { AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, } from '../../errors/abi.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nconst docsPath = '/docs/contract/decodeDeployData';\nexport function decodeDeployData(parameters) {\n    const { abi, bytecode, data } = parameters;\n    if (data === bytecode)\n        return { bytecode };\n    const description = abi.find((x) => 'type' in x && x.type === 'constructor');\n    if (!description)\n        throw new AbiConstructorNotFoundError({ docsPath });\n    if (!('inputs' in description))\n        throw new AbiConstructorParamsNotFoundError({ docsPath });\n    if (!description.inputs || description.inputs.length === 0)\n        throw new AbiConstructorParamsNotFoundError({ docsPath });\n    const args = decodeAbiParameters(description.inputs, `0x${data.replace(bytecode, '')}`);\n    return { args, bytecode };\n}\n//# sourceMappingURL=decodeDeployData.js.map","import { concat } from '../data/concat.js';\nimport { isBytes } from '../data/isBytes.js';\nimport { pad } from '../data/pad.js';\nimport { slice } from '../data/slice.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toRlp } from '../encoding/toRlp.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getAddress } from './getAddress.js';\nexport function getContractAddress(opts) {\n    if (opts.opcode === 'CREATE2')\n        return getCreate2Address(opts);\n    return getCreateAddress(opts);\n}\nexport function getCreateAddress(opts) {\n    const from = toBytes(getAddress(opts.from));\n    let nonce = toBytes(opts.nonce);\n    if (nonce[0] === 0)\n        nonce = new Uint8Array([]);\n    return getAddress(`0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}`);\n}\nexport function getCreate2Address(opts) {\n    const from = toBytes(getAddress(opts.from));\n    const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {\n        size: 32,\n    });\n    const bytecodeHash = (() => {\n        if ('bytecodeHash' in opts) {\n            if (isBytes(opts.bytecodeHash))\n                return opts.bytecodeHash;\n            return toBytes(opts.bytecodeHash);\n        }\n        return keccak256(opts.bytecode, 'bytes');\n    })();\n    return getAddress(slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12));\n}\n//# sourceMappingURL=getContractAddress.js.map","import { createCursor } from '../cursor.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nexport function fromBlobs(parameters) {\n    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');\n    const blobs = (typeof parameters.blobs[0] === 'string'\n        ? parameters.blobs.map((x) => hexToBytes(x))\n        : parameters.blobs);\n    const length = blobs.reduce((length, blob) => length + blob.length, 0);\n    const data = createCursor(new Uint8Array(length));\n    let active = true;\n    for (const blob of blobs) {\n        const cursor = createCursor(blob);\n        while (active && cursor.position < blob.length) {\n            // First byte will be a zero 0x00 byte – we can skip.\n            cursor.incrementPosition(1);\n            let consume = 31;\n            if (blob.length - cursor.position < 31)\n                consume = blob.length - cursor.position;\n            for (const _ in Array.from({ length: consume })) {\n                const byte = cursor.readByte();\n                const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n                if (isTerminator) {\n                    active = false;\n                    break;\n                }\n                data.pushByte(byte);\n            }\n        }\n    }\n    const trimmedData = data.bytes.slice(0, data.position);\n    return (to === 'hex' ? bytesToHex(trimmedData) : trimmedData);\n}\n//# sourceMappingURL=fromBlobs.js.map","import { commitmentToVersionedHash, } from './commitmentToVersionedHash.js';\n/**\n * Transforms a list of sidecars to their versioned hashes.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, sidecarsToVersionedHashes, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * const versionedHashes = sidecarsToVersionedHashes({ sidecars })\n * ```\n */\nexport function sidecarsToVersionedHashes(parameters) {\n    const { sidecars, version } = parameters;\n    const to = parameters.to ?? (typeof sidecars[0].blob === 'string' ? 'hex' : 'bytes');\n    const hashes = [];\n    for (const { commitment } of sidecars) {\n        hashes.push(commitmentToVersionedHash({\n            commitment,\n            to,\n            version,\n        }));\n    }\n    return hashes;\n}\n//# sourceMappingURL=sidecarsToVersionedHashes.js.map","import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError, } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { localBatchGatewayRequest, localBatchGatewayUrl, } from './ens/localBatchGatewayRequest.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    const { ccipRead } = client;\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'\n        ? ccipRead.request\n        : ccipRequest;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = urls.includes(localBatchGatewayUrl)\n            ? await localBatchGatewayRequest({\n                data: callData,\n                ccipRequest: ccipRequest_,\n            })\n            : await ccipRequest_({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipRequest({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};\n        try {\n            const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {\n                body: JSON.stringify(body),\n                headers,\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map","export function defineChain(chain) {\n    return {\n        formatters: undefined,\n        fees: undefined,\n        serializers: undefined,\n        ...chain,\n    };\n}\n//# sourceMappingURL=defineChain.js.map","export function extractChain({ chains, id, }) {\n    return chains.find((chain) => chain.id === id);\n}\n//# sourceMappingURL=extractChain.js.map","export function isBytes(value) {\n    if (!value)\n        return false;\n    if (typeof value !== 'object')\n        return false;\n    if (!('BYTES_PER_ELEMENT' in value))\n        return false;\n    return (value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array');\n}\n//# sourceMappingURL=isBytes.js.map","import { BaseError } from '../../errors/base.js';\nimport { InvalidHexValueError, } from '../../errors/encoding.js';\nimport { createCursor, } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function fromRlp(value, to = 'hex') {\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new InvalidHexValueError(value);\n            return hexToBytes(value);\n        }\n        return value;\n    })();\n    const cursor = createCursor(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = fromRlpCursor(cursor, to);\n    return result;\n}\nfunction fromRlpCursor(cursor, to = 'hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'hex' ? bytesToHex(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new BaseError('Invalid RLP prefix');\n}\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(fromRlpCursor(cursor, to));\n    return value;\n}\n//# sourceMappingURL=fromRlp.js.map","import { EnsInvalidChainIdError, } from '../../errors/ens.js';\nconst SLIP44_MSB = 0x80000000;\n/**\n * @description Converts a chainId to a ENSIP-9 compliant coinType\n *\n * @example\n * toCoinType(10)\n * 2147483658n\n */\nexport function toCoinType(chainId) {\n    if (chainId === 1)\n        return 60n;\n    if (chainId >= SLIP44_MSB || chainId < 0)\n        throw new EnsInvalidChainIdError({ chainId });\n    return BigInt((0x80000000 | chainId) >>> 0);\n}\n//# sourceMappingURL=toCoinType.js.map","import { isHex } from '../data/isHex.js';\nimport { size } from '../data/size.js';\nexport function isHash(hash) {\n    return isHex(hash) && size(hash) === 32;\n}\n//# sourceMappingURL=isHash.js.map","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function ripemd160(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = noble_ripemd160(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=ripemd160.js.map","/**\n * Defines a KZG interface.\n *\n * @example\n * ```ts\n * import * as cKzg from 'c-kzg'\n * import { defineKzg } from 'viem'\n * import { mainnetTrustedSetupPath } from 'viem/node'\n *\n * cKzg.loadTrustedSetup(mainnetTrustedSetupPath)\n *\n * const kzg = defineKzg(cKzg)\n * ```\n */\nexport function defineKzg({ blobToKzgCommitment, computeBlobKzgProof, }) {\n    return {\n        blobToKzgCommitment,\n        computeBlobKzgProof,\n    };\n}\n//# sourceMappingURL=defineKzg.js.map","import { defineKzg, } from './defineKzg.js';\n/**\n * Sets up and returns a KZG interface.\n *\n * @example\n * ```ts\n * import * as cKzg from 'c-kzg'\n * import { setupKzg } from 'viem'\n * import { mainnetTrustedSetupPath } from 'viem/node'\n *\n * const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)\n * ```\n */\nexport function setupKzg(parameters, path) {\n    try {\n        parameters.loadTrustedSetup(path);\n    }\n    catch (e) {\n        const error = e;\n        if (!error.message.includes('trusted setup is already loaded'))\n            throw error;\n    }\n    return defineKzg(parameters);\n}\n//# sourceMappingURL=setupKzg.js.map","import { getTransactionCount } from '../actions/public/getTransactionCount.js';\nimport { LruMap } from './lru.js';\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(parameters) {\n    const { source } = parameters;\n    const deltaMap = new Map();\n    const nonceMap = new LruMap(8192);\n    const promiseMap = new Map();\n    const getKey = ({ address, chainId }) => `${address}.${chainId}`;\n    return {\n        async consume({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            const promise = this.get({ address, chainId, client });\n            this.increment({ address, chainId });\n            const nonce = await promise;\n            await source.set({ address, chainId }, nonce);\n            nonceMap.set(key, nonce);\n            return nonce;\n        },\n        async increment({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            const delta = deltaMap.get(key) ?? 0;\n            deltaMap.set(key, delta + 1);\n        },\n        async get({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            let promise = promiseMap.get(key);\n            if (!promise) {\n                promise = (async () => {\n                    try {\n                        const nonce = await source.get({ address, chainId, client });\n                        const previousNonce = nonceMap.get(key) ?? 0;\n                        if (previousNonce > 0 && nonce <= previousNonce)\n                            return previousNonce + 1;\n                        nonceMap.delete(key);\n                        return nonce;\n                    }\n                    finally {\n                        this.reset({ address, chainId });\n                    }\n                })();\n                promiseMap.set(key, promise);\n            }\n            const delta = deltaMap.get(key) ?? 0;\n            return delta + (await promise);\n        },\n        reset({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            deltaMap.delete(key);\n            promiseMap.delete(key);\n        },\n    };\n}\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc() {\n    return {\n        async get(parameters) {\n            const { address, client } = parameters;\n            return getTransactionCount(client, {\n                address,\n                blockTag: 'pending',\n            });\n        },\n        set() { },\n    };\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n    source: jsonRpc(),\n});\n//# sourceMappingURL=nonceManager.js.map","import { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into signature format.\n *\n * @param signature The compact signature to convert.\n * @returns The compact signature in signature format.\n *\n * @example\n * compactSignatureToSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * })\n * // {\n * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n * //   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * //   v: 27n\n * // }\n */\nexport function compactSignatureToSignature({ r, yParityAndS, }) {\n    const yParityAndS_bytes = hexToBytes(yParityAndS);\n    const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0;\n    const s = yParityAndS_bytes;\n    if (yParity === 1)\n        s[0] &= 0x7f;\n    return { r, s: bytesToHex(s), yParity };\n}\n//# sourceMappingURL=compactSignatureToSignature.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { sliceHex } from '../data/slice.js';\n/** Whether or not the signature is an ERC-6492 formatted signature. */\nexport function isErc6492Signature(signature) {\n    return sliceHex(signature, -32) === erc6492MagicBytes;\n}\n//# sourceMappingURL=isErc6492Signature.js.map","import { SignatureErc8010 } from 'ox/erc8010';\n/** Whether or not the signature is an ERC-8010 formatted signature. */\nexport function isErc8010Signature(signature) {\n    return SignatureErc8010.validate(signature);\n}\n//# sourceMappingURL=isErc8010Signature.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { numberToHex } from '../encoding/toHex.js';\n/**\n * @description Parses a hex formatted compact signature into a structured compact signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseCompactSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', yParityAndS: '0x...' }\n */\nexport function parseCompactSignature(signatureHex) {\n    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));\n    return {\n        r: numberToHex(r, { size: 32 }),\n        yParityAndS: numberToHex(s, { size: 32 }),\n    };\n}\n//# sourceMappingURL=parseCompactSignature.js.map","import { decodeAbiParameters, } from '../abi/decodeAbiParameters.js';\nimport { isErc6492Signature, } from './isErc6492Signature.js';\n/**\n * @description Parses a hex-formatted ERC-6492 flavoured signature.\n * If the signature is not in ERC-6492 format, then the underlying (original) signature is returned.\n *\n * @param signature ERC-6492 signature in hex format.\n * @returns The parsed ERC-6492 signature.\n *\n * @example\n * parseSignature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')\n * // { address: '0x...', data: '0x...', signature: '0x...' }\n */\nexport function parseErc6492Signature(signature) {\n    if (!isErc6492Signature(signature))\n        return { signature };\n    const [address, data, signature_] = decodeAbiParameters([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], signature);\n    return { address, data, signature: signature_ };\n}\n//# sourceMappingURL=parseErc6492Signature.js.map","import { SignatureErc8010 } from 'ox/erc8010';\nimport { numberToHex } from '../encoding/toHex.js';\nimport { isErc8010Signature, } from './isErc8010Signature.js';\n/**\n * @description Parses a hex-formatted ERC-8010 flavoured signature.\n * If the signature is not in ERC-8010 format, then the underlying (original) signature is returned.\n *\n * @param signature ERC-8010 signature in hex format.\n * @returns The parsed ERC-8010 signature.\n */\nexport function parseErc8010Signature(signature) {\n    if (!isErc8010Signature(signature))\n        return { signature };\n    const { authorization: authorization_ox, to, ...rest } = SignatureErc8010.unwrap(signature);\n    return {\n        authorization: {\n            address: authorization_ox.address,\n            chainId: authorization_ox.chainId,\n            nonce: Number(authorization_ox.nonce),\n            r: numberToHex(authorization_ox.r, { size: 32 }),\n            s: numberToHex(authorization_ox.s, { size: 32 }),\n            yParity: authorization_ox.yParity,\n        },\n        ...(to ? { address: to } : {}),\n        ...rest,\n    };\n}\n//# sourceMappingURL=parseErc8010Signature.js.map","import { hashMessage } from './hashMessage.js';\nimport { recoverAddress, } from './recoverAddress.js';\nexport async function recoverMessageAddress({ message, signature, }) {\n    return recoverAddress({ hash: hashMessage(message), signature });\n}\n//# sourceMappingURL=recoverMessageAddress.js.map","import { keccak256 } from '../hash/keccak256.js';\nimport { parseTransaction } from '../transaction/parseTransaction.js';\nimport { serializeTransaction, } from '../transaction/serializeTransaction.js';\nimport { recoverAddress, } from './recoverAddress.js';\nexport async function recoverTransactionAddress(parameters) {\n    const { serializedTransaction, signature: signature_ } = parameters;\n    const transaction = parseTransaction(serializedTransaction);\n    const signature = signature_ ?? {\n        r: transaction.r,\n        s: transaction.s,\n        v: transaction.v,\n        yParity: transaction.yParity,\n    };\n    const serialized = serializeTransaction({\n        ...transaction,\n        r: undefined,\n        s: undefined,\n        v: undefined,\n        yParity: undefined,\n        sidecars: undefined,\n    });\n    return await recoverAddress({\n        hash: keccak256(serialized),\n        signature,\n    });\n}\n//# sourceMappingURL=recoverTransactionAddress.js.map","import { hashTypedData } from './hashTypedData.js';\nimport { recoverAddress, } from './recoverAddress.js';\nexport async function recoverTypedDataAddress(parameters) {\n    const { domain, message, primaryType, signature, types } = parameters;\n    return recoverAddress({\n        hash: hashTypedData({\n            domain,\n            message,\n            primaryType,\n            types,\n        }),\n        signature,\n    });\n}\n//# sourceMappingURL=recoverTypedDataAddress.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hexToBigInt } from '../encoding/fromHex.js';\n/**\n * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into hex format.\n *\n * @param signature The compact signature to convert.\n * @returns The compact signature in hex format.\n *\n * @example\n * serializeCompactSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeCompactSignature({ r, yParityAndS, }) {\n    return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(yParityAndS)).toCompactHex()}`;\n}\n//# sourceMappingURL=serializeCompactSignature.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concatHex } from '../data/concat.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature(parameters) {\n    const { address, data, signature, to = 'hex' } = parameters;\n    const signature_ = concatHex([\n        encodeAbiParameters([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),\n        erc6492MagicBytes,\n    ]);\n    if (to === 'hex')\n        return signature_;\n    return hexToBytes(signature_);\n}\n//# sourceMappingURL=serializeErc6492Signature.js.map","import { SignatureErc8010 } from 'ox/erc8010';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Serializes a ERC-8010 flavoured signature into hex format.\n *\n * @param signature ERC-8010 signature in object format.\n * @returns ERC-8010 signature in hex format.\n */\nexport function serializeErc8010Signature(parameters) {\n    const { address, data, signature, to = 'hex' } = parameters;\n    const signature_ = SignatureErc8010.wrap({\n        authorization: {\n            address: parameters.authorization.address,\n            chainId: parameters.authorization.chainId,\n            nonce: BigInt(parameters.authorization.nonce),\n            r: BigInt(parameters.authorization.r),\n            s: BigInt(parameters.authorization.s),\n            yParity: parameters.authorization.yParity,\n        },\n        data,\n        signature,\n        to: address,\n    });\n    if (to === 'hex')\n        return signature_;\n    return hexToBytes(signature_);\n}\n//# sourceMappingURL=serializeErc8010Signature.js.map","import { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * @description Converts a signature into an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098).\n *\n * @param signature The signature to convert.\n * @returns The signature in compact format.\n *\n * @example\n * signatureToCompactSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n *   yParity: 0\n * })\n * // {\n * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n * //   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'\n * // }\n */\nexport function signatureToCompactSignature(signature) {\n    const { r, s, v, yParity } = signature;\n    const yParity_ = Number(yParity ?? v - 27n);\n    let yParityAndS = s;\n    if (yParity_ === 1) {\n        const bytes = hexToBytes(s);\n        bytes[0] |= 0x80;\n        yParityAndS = bytesToHex(bytes);\n    }\n    return { r, yParityAndS };\n}\n//# sourceMappingURL=signatureToCompactSignature.js.map","import { getAddress } from '../address/getAddress.js';\nimport { isAddressEqual, } from '../address/isAddressEqual.js';\nimport { recoverAddress, } from './recoverAddress.js';\n/**\n * Verify that a message was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyHash` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyHash}\n *\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash({ address, hash, signature, }) {\n    return isAddressEqual(getAddress(address), await recoverAddress({ hash, signature }));\n}\n//# sourceMappingURL=verifyHash.js.map","import { getAddress } from '../address/getAddress.js';\nimport { isAddressEqual, } from '../address/isAddressEqual.js';\nimport { recoverMessageAddress, } from './recoverMessageAddress.js';\n/**\n * Verify that a message was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}\n *\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage({ address, message, signature, }) {\n    return isAddressEqual(getAddress(address), await recoverMessageAddress({ message, signature }));\n}\n//# sourceMappingURL=verifyMessage.js.map","import { getAddress } from '../address/getAddress.js';\nimport { isAddressEqual, } from '../address/isAddressEqual.js';\nimport { recoverTypedDataAddress, } from './recoverTypedDataAddress.js';\n/**\n * Verify that typed data was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}\n *\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData(parameters) {\n    const { address, domain, message, primaryType, signature, types } = parameters;\n    return isAddressEqual(getAddress(address), await recoverTypedDataAddress({\n        domain,\n        message,\n        primaryType,\n        signature,\n        types,\n    }));\n}\n//# sourceMappingURL=verifyTypedData.js.map","import { InvalidSerializedTransactionTypeError, } from '../../errors/transaction.js';\nimport { sliceHex } from '../data/slice.js';\nimport { hexToNumber } from '../encoding/fromHex.js';\nexport function getSerializedTransactionType(serializedTransaction) {\n    const serializedType = sliceHex(serializedTransaction, 0, 1);\n    if (serializedType === '0x04')\n        return 'eip7702';\n    if (serializedType === '0x03')\n        return 'eip4844';\n    if (serializedType === '0x02')\n        return 'eip1559';\n    if (serializedType === '0x01')\n        return 'eip2930';\n    if (serializedType !== '0x' && hexToNumber(serializedType) >= 0xc0)\n        return 'legacy';\n    throw new InvalidSerializedTransactionTypeError({ serializedType });\n}\n//# sourceMappingURL=getSerializedTransactionType.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { InvalidLegacyVError, InvalidSerializedTransactionError, } from '../../errors/transaction.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toBlobSidecars } from '../blob/toBlobSidecars.js';\nimport { isHex } from '../data/isHex.js';\nimport { padHex } from '../data/pad.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBigInt, hexToNumber, } from '../encoding/fromHex.js';\nimport { fromRlp } from '../encoding/fromRlp.js';\nimport { isHash } from '../hash/isHash.js';\nimport { assertTransactionEIP1559, assertTransactionEIP2930, assertTransactionEIP4844, assertTransactionEIP7702, assertTransactionLegacy, } from './assertTransaction.js';\nimport { getSerializedTransactionType, } from './getSerializedTransactionType.js';\nexport function parseTransaction(serializedTransaction) {\n    const type = getSerializedTransactionType(serializedTransaction);\n    if (type === 'eip1559')\n        return parseTransactionEIP1559(serializedTransaction);\n    if (type === 'eip2930')\n        return parseTransactionEIP2930(serializedTransaction);\n    if (type === 'eip4844')\n        return parseTransactionEIP4844(serializedTransaction);\n    if (type === 'eip7702')\n        return parseTransactionEIP7702(serializedTransaction);\n    return parseTransactionLegacy(serializedTransaction);\n}\nfunction parseTransactionEIP7702(serializedTransaction) {\n    const transactionArray = toTransactionArray(serializedTransaction);\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s,] = transactionArray;\n    if (transactionArray.length !== 10 && transactionArray.length !== 13)\n        throw new InvalidSerializedTransactionError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                authorizationList,\n                ...(transactionArray.length > 9\n                    ? {\n                        v,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serializedTransaction,\n            type: 'eip7702',\n        });\n    const transaction = {\n        chainId: hexToNumber(chainId),\n        type: 'eip7702',\n    };\n    if (isHex(to) && to !== '0x')\n        transaction.to = to;\n    if (isHex(gas) && gas !== '0x')\n        transaction.gas = hexToBigInt(gas);\n    if (isHex(data) && data !== '0x')\n        transaction.data = data;\n    if (isHex(nonce))\n        transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce);\n    if (isHex(value) && value !== '0x')\n        transaction.value = hexToBigInt(value);\n    if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = parseAccessList(accessList);\n    if (authorizationList.length !== 0 && authorizationList !== '0x')\n        transaction.authorizationList = parseAuthorizationList(authorizationList);\n    assertTransactionEIP7702(transaction);\n    const signature = transactionArray.length === 13\n        ? parseEIP155Signature(transactionArray)\n        : undefined;\n    return { ...signature, ...transaction };\n}\nfunction parseTransactionEIP4844(serializedTransaction) {\n    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);\n    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;\n    const transactionArray = hasNetworkWrapper\n        ? transactionOrWrapperArray[0]\n        : transactionOrWrapperArray;\n    const wrapperArray = hasNetworkWrapper\n        ? transactionOrWrapperArray.slice(1)\n        : [];\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s,] = transactionArray;\n    const [blobs, commitments, proofs] = wrapperArray;\n    if (!(transactionArray.length === 11 || transactionArray.length === 14))\n        throw new InvalidSerializedTransactionError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        v,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serializedTransaction,\n            type: 'eip4844',\n        });\n    const transaction = {\n        blobVersionedHashes: blobVersionedHashes,\n        chainId: hexToNumber(chainId),\n        to,\n        type: 'eip4844',\n    };\n    if (isHex(gas) && gas !== '0x')\n        transaction.gas = hexToBigInt(gas);\n    if (isHex(data) && data !== '0x')\n        transaction.data = data;\n    if (isHex(nonce))\n        transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce);\n    if (isHex(value) && value !== '0x')\n        transaction.value = hexToBigInt(value);\n    if (isHex(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')\n        transaction.maxFeePerBlobGas = hexToBigInt(maxFeePerBlobGas);\n    if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = parseAccessList(accessList);\n    if (blobs && commitments && proofs)\n        transaction.sidecars = toBlobSidecars({\n            blobs: blobs,\n            commitments: commitments,\n            proofs: proofs,\n        });\n    assertTransactionEIP4844(transaction);\n    const signature = transactionArray.length === 14\n        ? parseEIP155Signature(transactionArray)\n        : undefined;\n    return { ...signature, ...transaction };\n}\nfunction parseTransactionEIP1559(serializedTransaction) {\n    const transactionArray = toTransactionArray(serializedTransaction);\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12))\n        throw new InvalidSerializedTransactionError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        v,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serializedTransaction,\n            type: 'eip1559',\n        });\n    const transaction = {\n        chainId: hexToNumber(chainId),\n        type: 'eip1559',\n    };\n    if (isHex(to) && to !== '0x')\n        transaction.to = to;\n    if (isHex(gas) && gas !== '0x')\n        transaction.gas = hexToBigInt(gas);\n    if (isHex(data) && data !== '0x')\n        transaction.data = data;\n    if (isHex(nonce))\n        transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce);\n    if (isHex(value) && value !== '0x')\n        transaction.value = hexToBigInt(value);\n    if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = parseAccessList(accessList);\n    assertTransactionEIP1559(transaction);\n    const signature = transactionArray.length === 12\n        ? parseEIP155Signature(transactionArray)\n        : undefined;\n    return { ...signature, ...transaction };\n}\nfunction parseTransactionEIP2930(serializedTransaction) {\n    const transactionArray = toTransactionArray(serializedTransaction);\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11))\n        throw new InvalidSerializedTransactionError({\n            attributes: {\n                chainId,\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 8\n                    ? {\n                        v,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serializedTransaction,\n            type: 'eip2930',\n        });\n    const transaction = {\n        chainId: hexToNumber(chainId),\n        type: 'eip2930',\n    };\n    if (isHex(to) && to !== '0x')\n        transaction.to = to;\n    if (isHex(gas) && gas !== '0x')\n        transaction.gas = hexToBigInt(gas);\n    if (isHex(data) && data !== '0x')\n        transaction.data = data;\n    if (isHex(nonce))\n        transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce);\n    if (isHex(value) && value !== '0x')\n        transaction.value = hexToBigInt(value);\n    if (isHex(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = hexToBigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = parseAccessList(accessList);\n    assertTransactionEIP2930(transaction);\n    const signature = transactionArray.length === 11\n        ? parseEIP155Signature(transactionArray)\n        : undefined;\n    return { ...signature, ...transaction };\n}\nfunction parseTransactionLegacy(serializedTransaction) {\n    const transactionArray = fromRlp(serializedTransaction, 'hex');\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;\n    if (!(transactionArray.length === 6 || transactionArray.length === 9))\n        throw new InvalidSerializedTransactionError({\n            attributes: {\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                ...(transactionArray.length > 6\n                    ? {\n                        v: chainIdOrV_,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serializedTransaction,\n            type: 'legacy',\n        });\n    const transaction = {\n        type: 'legacy',\n    };\n    if (isHex(to) && to !== '0x')\n        transaction.to = to;\n    if (isHex(gas) && gas !== '0x')\n        transaction.gas = hexToBigInt(gas);\n    if (isHex(data) && data !== '0x')\n        transaction.data = data;\n    if (isHex(nonce))\n        transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce);\n    if (isHex(value) && value !== '0x')\n        transaction.value = hexToBigInt(value);\n    if (isHex(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = hexToBigInt(gasPrice);\n    assertTransactionLegacy(transaction);\n    if (transactionArray.length === 6)\n        return transaction;\n    const chainIdOrV = isHex(chainIdOrV_) && chainIdOrV_ !== '0x'\n        ? hexToBigInt(chainIdOrV_)\n        : 0n;\n    if (s === '0x' && r === '0x') {\n        if (chainIdOrV > 0)\n            transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Number((v - 35n) / 2n);\n    if (chainId > 0)\n        transaction.chainId = chainId;\n    else if (v !== 27n && v !== 28n)\n        throw new InvalidLegacyVError({ v });\n    transaction.v = v;\n    transaction.s = s;\n    transaction.r = r;\n    transaction.yParity = v % 2n === 0n ? 1 : 0;\n    return transaction;\n}\nexport function toTransactionArray(serializedTransaction) {\n    return fromRlp(`0x${serializedTransaction.slice(4)}`, 'hex');\n}\nexport function parseAccessList(accessList_) {\n    const accessList = [];\n    for (let i = 0; i < accessList_.length; i++) {\n        const [address, storageKeys] = accessList_[i];\n        if (!isAddress(address, { strict: false }))\n            throw new InvalidAddressError({ address });\n        accessList.push({\n            address: address,\n            storageKeys: storageKeys.map((key) => (isHash(key) ? key : trim(key))),\n        });\n    }\n    return accessList;\n}\nfunction parseAuthorizationList(serializedAuthorizationList) {\n    const authorizationList = [];\n    for (let i = 0; i < serializedAuthorizationList.length; i++) {\n        const [chainId, address, nonce, yParity, r, s] = serializedAuthorizationList[i];\n        authorizationList.push({\n            address,\n            chainId: chainId === '0x' ? 0 : hexToNumber(chainId),\n            nonce: nonce === '0x' ? 0 : hexToNumber(nonce),\n            ...parseEIP155Signature([yParity, r, s]),\n        });\n    }\n    return authorizationList;\n}\nfunction parseEIP155Signature(transactionArray) {\n    const signature = transactionArray.slice(-3);\n    const v = signature[0] === '0x' || hexToBigInt(signature[0]) === 0n ? 27n : 28n;\n    return {\n        r: padHex(signature[1], { size: 32 }),\n        s: padHex(signature[2], { size: 32 }),\n        v,\n        yParity: v === 27n ? 0 : 1,\n    };\n}\n//# sourceMappingURL=parseTransaction.js.map","import { etherUnits } from '../../constants/unit.js';\nimport { parseUnits } from './parseUnits.js';\n/**\n * Converts a string representation of ether to numerical wei.\n *\n * - Docs: https://viem.sh/docs/utilities/parseEther\n *\n * @example\n * import { parseEther } from 'viem'\n *\n * parseEther('420')\n * // 420000000000000000000n\n */\nexport function parseEther(ether, unit = 'wei') {\n    return parseUnits(ether, etherUnits[unit]);\n}\n//# sourceMappingURL=parseEther.js.map","import { gweiUnits } from '../../constants/unit.js';\nimport { parseUnits } from './parseUnits.js';\n/**\n * Converts a string representation of gwei to numerical wei.\n *\n * - Docs: https://viem.sh/docs/utilities/parseGwei\n *\n * @example\n * import { parseGwei } from 'viem'\n *\n * parseGwei('420')\n * // 420000000000n\n */\nexport function parseGwei(ether, unit = 'wei') {\n    return parseUnits(ether, gweiUnits[unit]);\n}\n//# sourceMappingURL=parseGwei.js.map"],"names":[],"sourceRoot":""}